## proj

Кроссплатформенная C++20 система сборки с менеджером зависимостей.

### Мотивация и цели

Как только возникает идея C++ проекта, хотелось бы просто задать его имя и краткое описание, и сразу же начинать писать
код, собирая релизы одной командой (или кликом), не теряя при этом в производительности сборки.  
Однако в реальности приходится создавать вручную или копипастить каждый раз типовые `CMakeLists.txt`, `README.md`,
структуру папок, либо допиливать созданный по шаблону IDE проект.  
Поэтому `proj` это утилита для создания и сборки C++ проектов с внешними зависимостями, по аналогии с `maven` для экосистемы Java, `dotnet` для .NET и `cargo`
для Rust.

### Основные концепции
Полная совместимость с существующими технологиями, не изобретать велосипед и новые конфиги.
1. Для сборки используется [`cmake`](https://cmake.org/)
1. Для поиска и добавления зависимостей используется [`vcpkg`](https://github.com/microsoft/vcpkg)
1. Возможность сборки проекта на любой ОС без зависимости от `proj`
1. Полная совместимость созданных проектов со всеми IDE "из коробки" без плагинов.

### Как установить утилиту?

Check in your package manager or [download here](https://github.com/demidko/proj/releases)

### Как использовать?

`proj -n name -d 'description of your directory'`

Эта команда создаёт cmake-конфигурацию проекта и тестов, точки входа, подтягивает `vcpkg` и минимально неообходимые
зависимости для утилит командной строки, добавляет `README` и завершается все это созданием скрипта сборки проекта в
один клик. Таким образом, созданные проекты поддерживаются в `CLion`, `Visual Studio`, `VS Code` и могут быть легко
дополнены любыми зависимостями из `vcpkg`.

### Как собирать исходный код утилиты?

Нам понадобится система сборки [`cmake`](https://cmake.org/download) и менеджер
библиотек [`vcpkg`](https://github.com/microsoft/vcpkg). Их легко можно установить пакетным менеджером, например `brew`.

1. Устанавливаем фреймворк для тестирования:  
   `vcpkg install` [`catch2`](https://github.com/catchorg/Catch2)
1. Устанавливаем зависимость для парсинга аргументов командной строки:  
   `vcpkg install` [`cli11`](https://github.com/CLIUtils/CLI11)
1. Устанавливаем fmt:  
   `vcpkg install` [`fmt`](https://github.com/fmtlib/fmt)
1. Подготавливаем проект для сборки с использованием зависимостей `vcpkg`:  
   ```cmake `vcpkg integrate install | tail -1 | cut -d \" -f2` -DCMAKE_BUILD_TYPE=Release -G "Unix Makefiles" -B cmake-build-release```  
   На Windows вместо кода в кавычках, вручную подставьте параметр полученный вызовом `vcpkg integrate install`.
1. Собираем проект и тесты:  
   `cmake --build cmake-build-release --target all`  
   После этого в директории `cmake-build-release` основная self-executable утилита появится под именем `proj`.  
   Тесты можно выполнить запустив расположенный рядом файл `test`.

### Сборка утилиты с использованием IDE?

1. Устанавливаем фреймворк для тестирования:  
   `vcpkg install catch2`
1. Устанавливаем зависимость для парсинга аргументов командной строки:  
   `vcpkg install cli11`
1. Устанавливаем fmt:  
   `vcpkg install` [`fmt`](https://github.com/fmtlib/fmt)
1. Установите для `CMake options` результат исполнения команды `vcpkg integrate install`.
1. Не забудьте выбрать релиз-конфигурацию. Дальше используйте обычный интерфейс сборки.

### Соглашения насчет исходного кода утилиты?

* Точка входа обязательно должна быть расположена в файле `Main.cpp` для корректной сборки.
* Для инициализации ресурсов используем [современную передачу параметров по значению](https://habr.com/ru/post/460955/),
  а не по константной ссылке.
* В релизную сборку попадает только результат компиляции `*.cpp` файлов в папке `src`.
* Папка `src` содержит `*.cpp` и `*.h` файлы проекта совместно.
* Папка `test` содержит `*.cpp` и `*.h` файлы тестов проекта совместно.
* Каждый `*.h` файл должен определять в глобальном пространстве имен только одну сущность, название которой должно
  совпадать с именем файла.
* Содержимое `*.cpp` файлов не задекларированное в `*.h` файле должно быть защищено от `external linkage` из других
  едениц компиляции путём добавления в анонимное пространство имён или же добавления ключевого слова `static`.

### TODO

1. Утилита несет разворачивает для каждого проекта билд скрипты для любых ОС.
1. Билд скрипты базируются на подтягиваемом репозитории vcpkg.
1. Билд скрипты проверяют подтянут ли и собран ли vcpkg.
1. Билд скрипты сканируют `CMakeLists.txt` и сопоставляют все инструкции find_package с зависимостями которые нужно
   подтянуть при помощи vcpkg.
1. Билд скрипты используют локальный vcpkg для разруливания зависимостей.
1. Утилита добавляет в README.md краткий мануал как искать и добавлять зависимости.
1. Утилита добавляет в README.md инструкцию по сборке проекта с помощью билд скрипта.
1. Добавить утилиту в репозитории популярных менеджеров зависимостей.
1. Написать статьи на хабр, reddit, hackernews.
1. Добавить больше типов проектов.
1. Бесконечный цикл багфиксов.
