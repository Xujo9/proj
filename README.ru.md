## proj

Кроссплатформенная C++20 система сборки с менеджером зависимостей. Работает за счет
интеграции [`cmake`](https://cmake.org/) с [`vcpkg`](https://github.com/microsoft/vcpkg).

### Мотивация и цели

В суровом мире C++ ...

* Когда возникает идея, приходится создавать вручную `CMakeLists.txt`, `README.md`, структуру папок, либо допиливать до
  переносимого состояния созданный IDE проект.
* Не существует менеджмента зависимостей без приседаний с бубном.
* Не существует кроссплатформенной сборки без Qt.

Эти проблемы накладываются друг на друга порождая боль и страдания разработчиков. Поэтому `proj` это утилита для
создания и сборки кроссплатформенных C++ проектов с внешними зависимостями, по аналогии с `maven` для экосистемы
Java, `dotnet` для экосистемы .NET и `cargo` для Rust.

### Возможности и преимущества `proj`

Полная совместимость с существующими технологиями.

* Для создания проекта указываем имя (и краткое описание опционально) и сразу же получаем готовый каркас со всей
  необходимой конфигурацией.
* Для сборки не добавляется никаких конфигурационных файлов кроме традиционнного `CMakeLists.txt`.
* Добавление зависимостей производится одной командой за счет интеграциии
  с [`vcpkg`](https://github.com/microsoft/vcpkg).
* Проект со всеми зависимостями можно собирать на разных ОС без изменения конфигурации.
* Созданные проекты поддерживаются всеми современными IDE "из коробки".

### Как установить утилиту?

Check in your package manager or [download here](https://github.com/demidko/proj/releases)

### Как использовать?

`proj -n name -d 'description of your directory'`

Эта команда создаёт cmake-конфигурацию проекта и тестов, точки входа, подтягивает `vcpkg` и минимально неообходимые
зависимости для утилит командной строки, добавляет `README` и завершается все это созданием скрипта сборки проекта в
один клик. Таким образом созданные проекты поддерживаются в `CLion`, `Visual Studio`, `VS Code`.

### Как собирать исходный код утилиты?

Нам понадобится система сборки [`cmake`](https://cmake.org/download) и менеджер
библиотек [`vcpkg`](https://github.com/microsoft/vcpkg). Их легко можно установить пакетным менеджером, например `brew`.

1. Устанавливаем фреймворк для тестирования:  
   `vcpkg install` [`catch2`](https://github.com/catchorg/Catch2)
1. Устанавливаем зависимость для парсинга аргументов командной строки:  
   `vcpkg install` [`cli11`](https://github.com/CLIUtils/CLI11)
1. Устанавливаем fmt:  
   `vcpkg install` [`fmt`](https://github.com/fmtlib/fmt)
1. Подготавливаем проект для сборки с использованием зависимостей `vcpkg`:  
   ```cmake `vcpkg integrate install | tail -1 | cut -d \" -f2` -DCMAKE_BUILD_TYPE=Release -G "Unix Makefiles" -B cmake-build-release```  
   На Windows вместо кода в кавычках, вручную подставьте параметр полученный вызовом `vcpkg integrate install`.
1. Собираем проект и тесты:  
   `cmake --build cmake-build-release --target all`  
   После этого в директории `cmake-build-release` основная self-executable утилита появится под именем `proj`.  
   Тесты можно выполнить запустив расположенный рядом файл `test`.

### Сборка утилиты с использованием IDE?

1. Устанавливаем фреймворк для тестирования:  
   `vcpkg install catch2`
1. Устанавливаем зависимость для парсинга аргументов командной строки:  
   `vcpkg install cli11`
1. Устанавливаем fmt:  
   `vcpkg install` [`fmt`](https://github.com/fmtlib/fmt)
1. Установите для `CMake options` результат исполнения команды `vcpkg integrate install`.
1. Не забудьте выбрать релиз-конфигурацию. Дальше используйте обычный интерфейс сборки.

### Соглашения насчет исходного кода утилиты?

* Точка входа обязательно должна быть расположена в файле `Main.cpp` для корректной сборки.
* Для инициализации ресурсов используем [современную передачу параметров по значению](https://habr.com/ru/post/460955/),
  а не по константной ссылке.
* В релизную сборку попадает только результат компиляции `*.cpp` файлов в папке `src`.
* Папка `src` содержит `*.cpp` и `*.h` файлы проекта совместно.
* Папка `test` содержит `*.cpp` и `*.h` файлы тестов проекта совместно.
* Каждый `*.h` файл должен определять в глобальном пространстве имен только одну сущность, название которой должно
  совпадать с именем файла.
* Содержимое `*.cpp` файлов не задекларированное в `*.h` файле должно быть защищено от `external linkage` из других
  едениц компиляции путём добавления в анонимное пространство имён или же добавления ключевого слова `static`.

### TODO

1. Утилита несет разворачивает для каждого проекта билд скрипты для любых ОС.
1. Билд скрипты базируются на подтягиваемом репозитории vcpkg.
1. Билд скрипты проверяют подтянут ли и собран ли vcpkg.
1. Билд скрипты сканируют `CMakeLists.txt` и сопоставляют все инструкции find_package с зависимостями которые нужно
   подтянуть при помощи vcpkg.
1. Билд скрипты используют локальный vcpkg для разруливания зависимостей.
1. Утилита добавляет в README.md краткий мануал как искать и добавлять зависимости.
1. Утилита добавляет в README.md инструкцию по сборке проекта с помощью билд скрипта.
1. Добавить утилиту в репозитории популярных менеджеров зависимостей.
1. Написать статьи на хабр, reddit, hackernews.
1. Добавить больше типов проектов.
1. Бесконечный цикл багфиксов.
