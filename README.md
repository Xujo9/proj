## co_exp
Эксперимент c корутинами C++20

### Как собирать?
Нам понадобится система сборки `cmake` и менеджер библиотек [`vcpkg`](https://github.com/microsoft/vcpkg). Их легко можно установить пакетным менеджером, например `brew`.
1. Устанавливаем фреймворк для тестирования:  
`vcpkg install catch2`
1. Устанавливаем зависимость для парсинга аргументов командной строки:  
`vcpkg install cli11`
1. Подготавливаем проект для сборки с использованием зависимостей `vcpkg`:  
```cmake `vcpkg integrate install | tail -1 |  cut -d \" -f2` -DCMAKE_BUILD_TYPE=Release -G "Unix Makefiles" -B cmake-build-release```  
На Windows вместо кода в кавычках, вручную подставьте параметр полученный вызовом `vcpkg integrate install`.
1. Собираем проект и тесты:  
`cmake --build cmake-build-release --target all`  
После этого в директории `cmake-build-release` основная self-executable утилита появится под именем `co_exp`.  
Тесты можно выполнить запустив расположенный рядом файл `test`.
   
### Сборка с использованием IDE?
1. Устанавливаем фреймворк для тестирования:  
   `vcpkg install catch2`
1. Устанавливаем зависимость для парсинга аргументов командной строки:  
   `vcpkg install cli11`
1. Установите для `CMake options` результат исполнения команды `vcpkg integrate install`.
1. Не забудьте выбрать релиз-конфигурацию.
Дальше используйте обычный интерфейс сборки.

### Code conventions:
В релизную сборку попадает только результат компиляции `*.cpp` файлов в папке `src`.  
Папка `src` содержит `*.cpp` и `*.h` файлы проекта.  
Папка `test` содержит `*.cpp` и `*.h` файлы тестов проекта.  
Используем `нижнее_подчеркивание` чтобы обечипечивать консистентность кода со стандартной библиотекой и ключевыми словами.  
Каждый `*.h` файл должен содержать в глобальном пространстве имен только одну сущность.  
Все содержимое должно быть вложено в нее и не находиться снаружи.  
Название этой сущности должно совпадать с именем файла.  